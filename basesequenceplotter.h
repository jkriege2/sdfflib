/**
 * \ingroup seqplot
 */
/*@{*/

/** \file basesequenceplotter.h
 */

#ifndef BASESEQUENCEPLOTTER_H
#define BASESEQUENCEPLOTTER_H

#include <string>
#include <sstream>
#include <map>
#include <vector>
#include <cstdio>
#include <stdint.h>

#include "jkiniparser.h"
#include "tools.h"
#include "sequencererror.h"
#include "channelmanager.h"
#include "sequencegenerator.h"
#include "nisequencegenerator.h"


namespace sequencer {

/** \brief list of possible marker types
 * \ingroup seqplot
 */
enum sp_marker_type {
	spInfo,        /*!< \brief just some information */
	spWarning,     /*!< \brief warning marker */
	spError        /*!< \brief error marker  */
};

/** \brief information about a marker in a sequencePlotter object
 * \ingroup seqplot
 */
typedef struct {
  sp_marker_type type;/*!< \brief type of the marker */
  double time;        /*!< \brief dataformat of the port (sgDouble=don't care) */
  std::string text;   /*!< \brief how to sort the pins within a port */
} sp_marker;


/**
 * \brief virtual base class for all sequence plotter objects
 * \ingroup seqplot
 *
 * simply write code for the virtual methods in this class an so generate your own plotter class.
 * Much of the needed maintenance is already done. For examples look at sequencePlotter and fastSequencePlotter
 * classes.
 *
 * Note that this is a child of sequencegenerator class which is also wirtual, so you will have to implement
 * the interfaces of both classes!
 *
 * These are the functions added to sequenceGenerator in this calss:
 * \li <tt>void plot_*(channelManager* cm, std::string filename, unsigned long height);</tt><br>
 *    plots all channels and the complete sequence (*=png, pdf, ps)
 * \li <tt>void plot_*(channelManager* cm, std::string filename, unsigned long height, double tstart, double tstop);</tt><br>
 *    plots all channels, but only a part [\c tstart ... \c tstop ] of the sequence. (*=png, pdf, ps)
 * \li If you don't want to generate a plot of all channels it is possible to generate a list of the
 * channels to be plottet. To do so, simply use the sel_add_channel() method. If you want to clear
 * the list use sel_clear_channels(). If the list is empty (after calling sel_clear_channels()) all
 * channels will be plottet!
 * \li Some pins may have an internal (linear) scaling (or inversion for digital channels). You may choose between
 * two output modes:
 *  -# plot the real output of the DA-Converters/digital pins (\c set_plot_scaled(false) )
 *  -# plot the scaled values (\c set_plot_scaled(true) )
 * .
 * \li You can also plot so called markers. That are vertical lines that span all plots and that have some text
 * at the bottom of the plot. They can have different colors, depending on the type of a marker. There are
 * information (blue), error (red) and warning (green) markers. They can be added to the plot by registering
 * them with add_info_marker(), add_error_marker() and add_warning_marker(). With clear_markers() all currently
 * registered markers will be deleted.
 *
 */
class baseSequencePlotter: public sequenceGenerator
{
  protected:
    /** \brief internal: this will contain a sorted list of all channels to be plottet. The list is generated by sort_channels(). */
    std::vector<std::string> channames;
    /** \brief internal: this map contains information about all channels to be plottet. This map shall be filled by init(). The information will be extracted from a channelManager object chanman. */
    std::map<std::string, sg_channel> channels;

    /** \brief internal: a list if markers that will be plottet into the graph */
    std::vector<sp_marker> markers;

    /** \brief internal: list of the channels to be plottet */
    std::vector<std::string> plotchannels;
    /** \brief number of channels */
    int chnum;
    /** \brief is there a list of channels to plot? */
    bool chlist;


    /** \brief internal: first timestep to be drawn */
    double t_start;
    /** \brief internal: last timestep to be drawn */
    double t_stop;
    /** \brief internal: = t_stop - t_start */
    double t_duration;


    /** \brief loads all channel names into channames in a meaningfull order, same algorithm, as in NIsequenceGenerator::sort_array() */
    void sort_channels();

    /** \brief returns the name of the nth channel */
    virtual std::string get_name(unsigned long num);

    /** \brief returns the number of channels */
    virtual inline unsigned long get_channel_count(){
      return channels.size();
    };

     /** \brief generates the hardware adress from the given channel (\c device+port+pin )
      *
      * This method uses NISEQGEN_DEVICE_PORT_DIVIDER and NISEQGEN_PORT_PIN_DIVIDER to form the complete hardware
      * adress. It works as follows:
      * - The strings are concatenated in the order \c device + \c port + \c pin.
      * - NISEQGEN_DEVICE_PORT_DIVIDER is put after the device name if the device name is non-empty.
      * - NISEQGEN_PORT_PIN_DIVIDER is put after the port name if the port name is non-empty.
      * .
      */
    std::string get_hardware_adress(cm_channel channel);


  public:
    /** \brief class constructor */
    baseSequencePlotter();
  	/** \brief class destructor */
  	~baseSequencePlotter();


    /** \brief add a channel to the selection of channels that should be plottet */
    virtual void sel_add_channel(std::string name);
    /** \brief clear the selection of channels that should be plottet */
    virtual void sel_clear_channels();

    /** \brief add a marker to the graph at time \c t with text \c txt of type \c typ */
    virtual void add_marker(sp_marker marker);
    /** \brief add a marker to the graph at time \c t with text \c txt of type \c typ */
    virtual void add_marker(double t, sp_marker_type typ, std::string txt);
    /** \brief add an information marker to the graph at time \c t with text \c txt of type \c typ */
    virtual inline void add_info_marker(double t, std::string txt) { add_marker(t, spInfo, txt); };
    /** \brief add a warning marker to the graph at time \c t with text \c txt of type \c typ */
    virtual inline void add_warning_marker(double t, std::string txt) { add_marker(t, spWarning, txt); };
    /** \brief add an error marker to the graph at time \c t with text \c txt of type \c typ */
    virtual inline void add_error_marker(double t, std::string txt) { add_marker(t, spError, txt); };
    /** \brief clear all registered markers */
    virtual void clear_markers();


};

}
#endif // BASESEQUENCEPLOTTER_H


/*@}*/
