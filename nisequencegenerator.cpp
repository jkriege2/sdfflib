// Class automatically generated by Dev-C++ New Class wizard

#include "nisequencegenerator.h" // class's header file


namespace sequencer {

// class constructor
NIsequenceGenerator::NIsequenceGenerator():
  sequenceGenerator()
{
	sample_timestep=5; // 5 µs
	end_time=5000; // 5 ms  => 1000 samples per channel
	portconfigfilename="ports.ini";
	timingconfigfilename="timing.ini";
	use_binary16=true;
	memusage=0;
	memusage_sample=0;
	private_mem_error_info="";
	use_variable_timing=false;
	vartiming_inifile="variable-timing.ini";
}

// class destructor
NIsequenceGenerator::~NIsequenceGenerator()
{
    clear();
	// insert your code here
}


void* NIsequenceGenerator::private_calloc(size_t count, size_t eltsize){
  //return calloc(count, eltsize);
  void* p= VirtualAlloc(NULL, count*eltsize, MEM_COMMIT|MEM_RESERVE|MEM_TOP_DOWN, PAGE_READWRITE);
  if (p!=NULL) {
    ZeroMemory(p, count*eltsize);
  } else {
    /* return the windows error message for an error code:
      taken and modified from http://msdn2.microsoft.com/en-us/library/ms701797.aspx */
    char* pMsgBuf = NULL;
    DWORD dwErrorCode=GetLastError();

    // Retrieve the Win32 error message.
    DWORD dwSize = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL, dwErrorCode, 0, (LPTSTR) &pMsgBuf, 0, NULL);

    // Return the description and size to the caller in the OUT parameters.
    if (dwSize>0)
    {
        private_mem_error_info=pMsgBuf;
        LocalFree(pMsgBuf);
    } else {
      private_mem_error_info="errorcode: "+inttostr(dwErrorCode);
    }
  }
  return p;
};

void NIsequenceGenerator::private_free(void *ptr, size_t size){
  //free(ptr);
  BOOL success=VirtualFree(ptr, 0, MEM_RELEASE);
};



void* NIsequenceGenerator::get_array(unsigned long num){
  if (num>=get_channel_count()) {
    SEQUENCER_ERRORN(SEQUENCER_ERROR_RANGE_NUM, "NIsequenceGenerator.get_array("+inttostr(num)+")");
  } else {
    std::map<std::string, sg_channel>::const_iterator i=channels.begin();
    if (num>0) for (size_t j=0; j<num; j++) ++i;
    return get_nth_array(channels[i->first].data);
  }
};


unsigned long NIsequenceGenerator::get_array_num(unsigned long num){
  if (num>=get_channel_count()) {
    SEQUENCER_ERRORN(SEQUENCER_ERROR_RANGE_NUM, "NIsequenceGenerator.get_array_num("+inttostr(num)+")");
  } else {
    std::map<std::string, sg_channel>::const_iterator i=channels.begin();
    if (num>0) for (size_t j=0; j<num; j++) ++i;
    return channels[i->first].data;
  }
};

std::string NIsequenceGenerator::get_name(unsigned long num){
  if (num>=get_channel_count()) {
    SEQUENCER_ERRORN(SEQUENCER_ERROR_RANGE_NUM, "NIsequenceGenerator.get_name("+inttostr(num)+")");
  } else {
    std::map<std::string, sg_channel>::const_iterator i=channels.begin();
    if (num>0) for (size_t j=0; j<num; j++) ++i;
    return channels[i->first].name;
  }
};


sg_dataformat NIsequenceGenerator::get_dataformat(unsigned long num){
  if (num>=get_array_count()) {
    SEQUENCER_ERRORN(SEQUENCER_ERROR_RANGE_NUM, "NIsequenceGenerator.get_dataformat("+inttostr(num)+")");
  } else {
    std::map<std::string, sg_channel>::const_iterator i=channels.begin();
    if (num>0) for (size_t j=0; j<num; j++) ++i;
    return get_nth_dataformat(channels[i->first].data);
  }
};


unsigned char NIsequenceGenerator::get_offset(unsigned long num){
  if (num>=get_channel_count()) {
    SEQUENCER_ERRORN(SEQUENCER_ERROR_RANGE_NUM, "NIsequenceGenerator.get_array("+inttostr(num)+")");
  } else {
    std::map<std::string, sg_channel>::const_iterator i=channels.begin();
    if (num>0) for (size_t j=0; j<num; j++) ++i;
    return channels[i->first].offset;
  }
};


void NIsequenceGenerator::set_analog(std::string channel, double time_start, double time_stop, double value){
  if ((time_start>end_time)||(time_stop>end_time)) SEQUENCER_ERRORN(SEQUENCER_ERROR_AFTERTIMEEND_NUM, "NIsequenceGenerator.set_analog(\""+channel+"\", "+floattostr(time_start)+", "+floattostr(time_stop)+", "+floattostr(value)+")");
  sg_dataformat df=get_dataformat(channel);
  if (df!=sgDouble && df!=sgBinary16) SEQUENCER_ERRORN(SEQUENCER_ERROR_NOTANALOG_NUM, "NIsequenceGenerator.set_analog(\""+channel+"\", "+floattostr(time_start)+", "+floattostr(time_stop)+", "+floattostr(value)+")");
  unsigned int num=get_array_num(channel);
  unsigned char offset=get_offset(channel);
  unsigned long long tstop=time_to_index(time_stop);
  if (time_stop>=end_time) tstop=array_size-1;
  unsigned long long tstart=time_to_index(time_start);
  sg_arraydata a=arrays[get_array_num(channel)];
  if (df==sgDouble) {
    double* aa=(double*)arrays[num].data;
    for (unsigned long long t=tstart; t<=tstop; t++) {
      aa[t*a.channels+offset]=value;
    }
  } else {
    int16* aa=(int16*)arrays[num].data;
    int16 v=(int16)(value/10.0*32767.0);
    //std::cout<<channel<<"["<<tstart<<" .. "<<tstop<<"] = ("<<value<<";   "<<v<<")     array_size = "<<array_size<<std::endl;
    for (unsigned long long t=tstart; t<=tstop; t++) {
      aa[t*a.channels+offset]=v;
    }
  }
};

void NIsequenceGenerator::set_linear(std::string channel, double time_start, double time_stop,  double startvalue, double endvalue){
  if ((time_start>end_time)||(time_stop>end_time)) SEQUENCER_ERRORN(SEQUENCER_ERROR_AFTERTIMEEND_NUM, "NIsequenceGenerator.set_linear(\""+channel+"\", "+floattostr(time_start)+", "+floattostr(time_stop)+", "+floattostr(endvalue)+")");
  sg_dataformat df=get_dataformat(channel);
  if (df!=sgDouble && df!=sgBinary16) SEQUENCER_ERRORN(SEQUENCER_ERROR_NOTANALOG_NUM, "NIsequenceGenerator.set_linear(\""+channel+"\", "+floattostr(time_start)+", "+floattostr(time_stop)+", "+floattostr(endvalue)+")");
  unsigned int num=get_array_num(channel);
  unsigned char offset=get_offset(channel);
  unsigned long long tstop=time_to_index(time_stop);
  unsigned long long tstop1=tstop;
  if (time_stop==end_time) tstop1=array_size-1;
  unsigned long long tstart=time_to_index(time_start);
  sg_arraydata a=arrays[get_array_num(channel)];
  double dV=(endvalue-startvalue)/mmax(1,tstop-tstart);
  double v=startvalue;
  if (df==sgDouble) {
    double* aa=(double*)a.data;
    for (unsigned long long t=tstart; t<=tstop; t++) {
      aa[t*a.channels+offset]=v;
      v+=dV;
    }
    if (tstop1>tstop) {
      for (unsigned long long t=tstop; t<=tstop1; t++) {
        aa[t*a.channels+offset]=v;
      }
    }
  } else {
    int16* aa=(int16*)arrays[num].data;
    for (unsigned long long t=tstart; t<=tstop; t++) {
      aa[t*a.channels+offset]=(int16)(v/10.0*32767.0);
      v+=dV;
    }
    if (tstop1>tstop) {
      for (unsigned long long t=tstop; t<=tstop1; t++) {
        aa[t*a.channels+offset]=(int16)(v/10.0*32767.0);
      }
    }
  }
};

void NIsequenceGenerator::set_digital(std::string channel, double time_start, double time_stop, bool value){
  if ((time_start>end_time)||(time_stop>end_time)) SEQUENCER_ERRORN(SEQUENCER_ERROR_AFTERTIMEEND_NUM, "NIsequenceGenerator.set_digital(\""+channel+"\", "+floattostr(time_start)+", "+floattostr(time_stop)+", "+booltostr(value)+")");
  unsigned int num=get_array_num(channel);
  unsigned char offset=get_offset(channel);
  sg_dataformat df=get_dataformat(channel);
  unsigned long long tstop=time_to_index(time_stop);
  if (time_stop==end_time) tstop=array_size-1;
  unsigned long long tstart=time_to_index(time_start);
  if (df==sgUInt32) {
    uint32_t* aa=(uint32_t*)arrays[num].data;
    for (unsigned long long t=tstart; t<=tstop; t++) {
      if (value) {set_bit(aa[t], offset)} else {clear_bit(aa[t], offset)}
    }
    return;
  }
  if (df==sgUInt8) {
    uint8_t* aa=(uint8_t*)arrays[num].data;
    for (unsigned long long t=tstart; t<=tstop; t++) {
      if (value) {set_bit(aa[t], offset);} else {clear_bit(aa[t], offset);}
    }
    return;
  }
  if (df==sgUInt16) {
    uint16_t* aa=(uint16_t*)arrays[num].data;
    for (unsigned long long t=tstart; t<=tstop; t++) {
      if (value) {set_bit(aa[t], offset);} else {clear_bit(aa[t], offset);}
//      std::cout<<t<<"   "<<offset<<std::endl;
    }
    return;
  }
  SEQUENCER_ERRORN(SEQUENCER_ERROR_NOTDIGITAL_NUM, "NIsequenceGenerator.set_digital(\""+channel+"\", "+floattostr(time_start)+", "+floattostr(time_stop)+", "+booltostr(value)+")");
};

void NIsequenceGenerator::set_digital(std::string channel, double timestep, bool value){
  if (timestep>end_time) SEQUENCER_ERRORN(SEQUENCER_ERROR_AFTERTIMEEND_NUM, "NIsequenceGenerator.set_digital(\""+channel+"\", "+floattostr(timestep)+", "+booltostr(value)+")");
  unsigned int num=get_array_num(channel);
  unsigned char offset=get_offset(channel);
  sg_dataformat df=get_dataformat(channel);
  if (df==sgUInt32) {
    if (value) {set_bit(((uint32_t*)arrays[num].data)[time_to_index(timestep)], offset);}
    else {clear_bit(((uint32_t*)arrays[num].data)[time_to_index(timestep)], offset);}
    return;
  }
  if (df==sgUInt8) {
    if (value) {set_bit(((uint8_t*)arrays[num].data)[time_to_index(timestep)], offset);}
    else {clear_bit(((uint8_t*)arrays[num].data)[time_to_index(timestep)], offset);}
    return;
  }
  if (df==sgUInt16) {
    if (value) {set_bit(((uint16_t*)arrays[num].data)[time_to_index(timestep)], offset);}
    else {clear_bit(((uint16_t*)arrays[num].data)[time_to_index(timestep)], offset);}
    return;
  }
  SEQUENCER_ERRORN(SEQUENCER_ERROR_NOTDIGITAL_NUM, "NIsequenceGenerator.set_digital(\""+channel+"\", "+floattostr(timestep)+", "+booltostr(value)+")");
};



void NIsequenceGenerator::init(channelManager* cm, double ssample_timestep, double send_time){
    if (debug && log!=NULL) {
      log->log_text("NIsequenceGenerator::init(cm, timestep="+floattostr(ssample_timestep)+", send_time="+floattostr(send_time)+")\n");
      log->inc_indent();
      log->log_linebreak();
    }

  //std::cout<<"init"<<std::endl;
  // first delete all previous data and try to read ports.ini
  clear();
  //std::cout<<"1"<<std::endl;
  read_ports_ini();
  //std::cout<<"2"<<std::endl;
  cmanager=cm;

  // init timing settings
  sample_timestep=ssample_timestep;
  end_time=send_time;
  if (send_time==-1) end_time=10*sample_timestep;
  array_size=(unsigned long long)(end_time/sample_timestep);

  // workaround, as on some devices samples_per_channel*num_channels has to be even integer, so make shure that array_sizze is even
  if (array_size % 2 != 0) array_size++;

  //std::cout<<"chan*arraysize = "<<array_size*(*cmanager).get_channel_count()<<std::endl;
  //std::cout<<"3"<<std::endl;

  // init channels and data arrays.
  if ((*cmanager).get_channel_count()>0) {
      /*
        (I) for each channel in the channelManager object:
            1. check whether there is already an array for the device and port of the channel
               if there is:      add the channel to this array
               if there is not:  create a new array, do not get memory for this array !!!
            2. generate and save the channel information
      */
    //std::cout<<"4"<<std::endl;
    for (size_t i=0; i<(*cmanager).get_channel_count(); i++) {
      std::string port=(*cmanager)[i].port_name;
      std::string device=(*cmanager)[i].device_name;
      int offset=0;
      int arraynum=-1;

      // ANALOG OUTPUT CHANNELS
      if (((*cmanager)[i].type==cmAnalogOutput) && is_used((*cmanager)[i].name) ) {
        if (get_array_count()>0) for (unsigned long j=0; j<get_array_count(); j++) {
          if ((arrays[j].port==port)&&(arrays[j].device==device)) {
            arraynum=j;
          }
        }
        if (arraynum==-1) {
          sg_arraydata a;
          a.port=port;
          a.device=device;
          a.channels=1;
          a.format=sgDouble;
          if (use_binary16) a.format=sgBinary16;
          arraynum=get_array_count();
          arrays.push_back(a);
          offset=0;
        } else {
          sg_arraydata a=arrays[arraynum];
          if (a.format!=sgDouble && a.format!=sgBinary16) SEQUENCER_ERRORN(SEQUENCER_ERROR_CHANNELDATAMISMATH_NUM, "NIsequenceGenerator.init(&cm, "+floattostr(ssample_timestep)+", "+floattostr(send_time)+"),\n trying to add channel='"+(*cmanager)[i].name+"'(analog) to device='"+device+"' port='"+port+"'(digital)");
          offset=a.channels;   a.channels++;
          arrays[arraynum]=a;
        }
        channels[(*cmanager)[i].name].name=(*cmanager)[i].name;
        channels[(*cmanager)[i].name].hardware_name=get_hardware_adress((*cmanager)[i]);
        channels[(*cmanager)[i].name].data=arraynum;
        channels[(*cmanager)[i].name].offset=offset;
      }

      // DIGITAL OUTPUT CHANNELS
      if (((*cmanager)[i].type==cmDigitalOutput) && is_used((*cmanager)[i].name) ) {
        if (get_array_count()>0) for (unsigned long j=0; j<get_array_count(); j++) {
          if ((arrays[j].port==port)&&(arrays[j].device==device)) {
            arraynum=j;
          }
        }
        if (arraynum==-1) {
          sg_arraydata a;
          a.port=port;
          a.device=device;
          a.channels=1;
          a.format=sgUInt8;
          arraynum=get_array_count();
          arrays.push_back(a);
          offset=0;
        } else {
          sg_arraydata a=arrays[arraynum];
          if (a.format==sgDouble || a.format==sgBinary16) SEQUENCER_ERRORN(SEQUENCER_ERROR_CHANNELDATAMISMATH_NUM, "NIsequenceGenerator.init(&cm, "+floattostr(ssample_timestep)+", "+floattostr(send_time)+"),\n trying to add channel='"+(*cmanager)[i].name+"'(digital) to device='"+device+"' port='"+port+"'(analog)");
          offset=a.channels;   a.channels++;
          if ((a.format==sgUInt8)&&(a.channels>8)) a.format=sgUInt16;
          if ((a.format==sgUInt16)&&(a.channels>16)) a.format=sgUInt32;
          if ((a.format==sgUInt32)&&(a.channels>32)) SEQUENCER_ERRORN(SEQUENCER_ERROR_TOOMANYCHANNELS_NUM, "NIsequenceGenerator.init(&cm, "+floattostr(ssample_timestep)+", "+floattostr(send_time)+")");
          arrays[arraynum]=a;
        }
        channels[(*cmanager)[i].name].name=(*cmanager)[i].name;
        channels[(*cmanager)[i].name].hardware_name=get_hardware_adress((*cmanager)[i]);
        channels[(*cmanager)[i].name].data=arraynum;
        channels[(*cmanager)[i].name].offset=offset;
      }
    }
//    std::cout<<"5"<<std::endl;
    /* (II) now allocate the memory for all arrays
            first call sort_array(i) to sort the lines in one array and under
            circumstances change the line-ordering to pin_name
    */
    if (debug && log!=NULL) {
      log->inc_indent();
      log->log_linebreak();
    }
    if (get_array_count()>0) for (size_t i=0; i<get_array_count(); i++) {
      sort_array(i);
//      std::cout<<"sorted"<<std::endl;
      if (arrays[i].format==sgDouble) {
        if (debug && log!=NULL) {
          double ms=(double)(array_size*arrays[i].channels*sizeof(double))/1024.0/1024.0;
          //std::cout<<std::endl<<ms<<std::endl;
          log->log_text(format("callocing double-array %2d       elements = %2ld x %6ld     size = "+floattostr(ms)+" MBytes", i, arrays[i].channels, array_size));
        }
        arrays[i].data=private_calloc(array_size*arrays[i].channels,sizeof(double));
        arrays[i].compare_data=private_calloc(arrays[i].channels,sizeof(double));
        arrays[i].size=array_size*arrays[i].channels*sizeof(double);
        memusage+=(double)(array_size*arrays[i].channels*sizeof(double))/1024.0/1024.0;
        memusage_sample+=(double)(arrays[i].channels*sizeof(double));
        if (debug && log!=NULL && arrays[i].data!=NULL) {
          log->log_text(format(" ... OK,   pointer-adress = 0x%p", arrays[i].data));
          log->log_linebreak();
        }
      }
      if (arrays[i].format==sgBinary16) {
        if (debug && log!=NULL) {
          double ms=(double)(array_size*arrays[i].channels*sizeof(int16))/1024.0/1024.0;
          log->log_text(format("callocing int16-array  %2d       elements = %2ld x %6ld     size = "+floattostr(ms)+" MBytes", i, arrays[i].channels, array_size));
        }
        arrays[i].data=private_calloc(array_size*arrays[i].channels,sizeof(int16));
        arrays[i].compare_data=private_calloc(arrays[i].channels,sizeof(int16));
        arrays[i].size=array_size*arrays[i].channels*sizeof(int16);
        memusage+=(double)(array_size*arrays[i].channels*sizeof(int16))/1024.0/1024.0;
        memusage_sample+=(double)(arrays[i].channels*sizeof(int16));
        if (debug && log!=NULL && arrays[i].data!=NULL) {
          log->log_text(format(" ... OK,   pointer-adress = 0x%p", arrays[i].data));
          log->log_linebreak();
        }
      }
      if (arrays[i].format==sgUInt8) {
        if (debug && log!=NULL) {
          double ms=(double)(array_size*sizeof(uint8_t))/1024.0/1024.0;
          log->log_text(format("callocing uint8-array  %2d       elements =  %6ld     size = "+floattostr(ms)+" MBytes", i, array_size));
        }
        arrays[i].data=private_calloc(array_size,sizeof(uint8_t));
        arrays[i].compare_data=private_calloc(1,sizeof(uint8_t));
        arrays[i].size=array_size*sizeof(uint8_t);
        memusage+=(double)(array_size*sizeof(uint8_t))/1024.0/1024.0;
        memusage_sample+=(double)(sizeof(uint8_t));
        if (debug && log!=NULL && arrays[i].data!=NULL) {
          log->log_text(format(" ... OK,   pointer-adress = 0x%p", arrays[i].data));
          log->log_linebreak();
        }
      }
      if (arrays[i].format==sgUInt16) {
        if (debug && log!=NULL) {
          double ms=(double)(array_size*sizeof(uint16_t))/1024.0/1024.0;
          log->log_text(format("callocing uint16-array %2d       elements = %6ld     size = "+floattostr(ms)+" MBytes", i, array_size));
        }
        arrays[i].data=private_calloc(array_size,sizeof(uint16_t));
        arrays[i].compare_data=private_calloc(1,sizeof(uint16_t));
        arrays[i].size=array_size*sizeof(uint16_t);
        memusage+=(double)(array_size*sizeof(uint32_t))/1024.0/1024.0;
        memusage_sample+=(double)(sizeof(uint32_t));
        if (debug && log!=NULL && arrays[i].data!=NULL) {
          log->log_text(format(" ... OK,   pointer-adress = 0x%p", arrays[i].data));
          log->log_linebreak();
        }
      }
      if (arrays[i].format==sgUInt32) {
        if (debug && log!=NULL) {
          double ms=(double)(array_size*sizeof(uint32_t))/1024.0/1024.0;
          log->log_text(format("callocing uint32-array %2d       elements = %6ld     size = "+floattostr(ms)+" MBytes", i, array_size));
        }
        arrays[i].data=private_calloc(array_size,sizeof(uint32_t));
        arrays[i].compare_data=private_calloc(1,sizeof(uint32_t));
        arrays[i].size=array_size*sizeof(uint32_t);
        memusage+=(double)(array_size*sizeof(uint32_t))/1024.0/1024.0;
        memusage_sample+=(double)(sizeof(uint32_t));
        if (debug && log!=NULL && arrays[i].data!=NULL) {
          log->log_text(format(" ... OK,   pointer-adress = 0x%p", arrays[i].data));
          log->log_linebreak();
        }
      }

      // check for data allocation errors
      if (arrays[i].data==NULL) {
        SEQUENCER_ERRORV(SEQUENCER_ERROR_MEMALLOC_NUM, "NIsequenceGenerator.init(&cm, "+floattostr(ssample_timestep)+", "+floattostr(send_time)+")", ("Virtual memory seems to be exhausted. Could not malloc data. Try to restart controlserver and maybe reboot the computer.\n Windows error messge was: "+private_mem_error_info).c_str());
      }
    }
    if (debug && log!=NULL) {
      log->dec_indent();
    }
  }
//  std::cout<<"init end"<<std::endl;
  cur_array_size=array_size;

  if (debug && log!=NULL) {
      log->log_text("array_size="+inttostr(array_size)+"\n");
      log->log_text("memusage="+bytestostr(memusage)+"\n");
      log->log_text("memusage_sample="+bytestostr(memusage_sample)+"\n");
    log->dec_indent();
    log->log_linebreak();
  }

};

void NIsequenceGenerator::use_initialvalues() {
  for (std::map<std::string, double>::const_iterator i=initialvalues.begin(); i!=initialvalues.end(); ++i) {
    if (i->second!=0) {
      if (channels.find(i->first)!=channels.end()) {
        if ((*cmanager)[i->first].type==cmDigitalOutput) {
          set_digital(i->first, 0, end_time, i->second>0);
        } else {
          set_analog(i->first, 0, end_time, i->second);
        }
      }
    }
  }
}

std::string NIsequenceGenerator::report(){
  std::string res;
  res+="end_time        =   "+floattostr(end_time)+ " micros\n";
  res+="sample_timestep =   "+floattostr(sample_timestep)+ " micros\n";
  res+="samples         =   "+floattostr(end_time/sample_timestep)+ "\n";
  res+="array_size      =   "+uinttostr(array_size)+ "\n";
  res+="cur_array_size  =   "+uinttostr(cur_array_size)+ "\n";
  res+="channel_count   =   "+uinttostr(get_channel_count())+ "\n";
  res+="array_count     =   "+uinttostr(get_array_count())+ "\n";
  if (get_channel_count()>0) {
    res+="\n";
    res+="- channels ------------------------------------------------------------------------------------------\n";
    int c=0;
    for (std::map<std::string, sg_channel>::const_iterator i=channels.begin(); i!=channels.end(); ++i) {

      res += "  channel "+inttostr(c)+ "'"+i->second.name+"':\n";
      res += "    hardware name = "+i->second.hardware_name+"\n";
      res += "    data number   = "+inttostr(i->second.data)+"\n";
      res += "    offset        = "+inttostr(i->second.offset)+"\n";
      c++;
    }
  }
  if (get_array_count()>0) {
    res+="\n";
    res+="- arrays --------------------------------------------------------------------------------------------\n";
    for (unsigned long i=0; i<get_array_count(); i++) {

      res+="  array "+inttostr(i)+":\n";
      res+="    number of channels   = "+inttostr(arrays[i].channels)+"\n";
      res+="    adresses             = "+arrays[i].adress_string+"\n";
      if (arrays[i].format==sgDouble) {
        res+="    dataformat           = double\n";
        res+="\n";
        res+="    data:\n";
        res+=doublearraytostr((double*)arrays[i].data, arrays[i].channels, array_size, false)+"\n\n";
      }
      if (arrays[i].format==sgBinary16) {
        res+="    dataformat           = int16\n";
        res+="\n";
        res+="    data:\n";
        //res+=doublearraytostr((double*)arrays[i].data, arrays[i].channels, array_size, false)+"\n\n";
      }
      if (arrays[i].format==sgUInt8) {
        res+="    dataformat           = unsigned int, 8-bit\n";
        res+="\n";
        res+="    data:\n";
        res+=uint8vectostr((uint8_t*)arrays[i].data, array_size, true, true, true, false)+"\n\n";
      }
      if (arrays[i].format==sgUInt16) {
        res+="    dataformat           = unsigned int, 16-bit\n";
        res+="\n";
        res+="    data:\n";
        res+=uint16vectostr((uint16_t*)arrays[i].data, array_size, true, true, true, false)+"\n\n";
      }
      if (arrays[i].format==sgUInt32) {
        res+="    dataformat           = unsigned int, 32-bit\n";
        res+="\n";
        res+="    data:\n";
        res+=uint32vectostr((uint32_t*)arrays[i].data, array_size, true, true, true, false)+"\n\n";
      }
    }
  }
  return res;
};

void NIsequenceGenerator::clear(){
  if (debug && log!=NULL) {
    log->inc_indent();
    log->log_linebreak();
  }
  if (get_array_count()>0) for (size_t i=0; i<get_array_count(); i++) {
    private_free(arrays[i].data, arrays[i].size);
    private_free(arrays[i].compare_data, arrays[i].size/cur_array_size);
    if (debug && log!=NULL) {
      log->log_text("freeing array "+inttostr(i)+ ":     size = "+floattostr(arrays[i].size/1024.0/1024.0)+ "MBytes\n");
    }
  }
  if (debug && log!=NULL) {
    log->dec_indent();
  }
  memusage=0;
  memusage_sample=0;
  arrays.clear();
  channels.clear();
  sample_timestep=5; // 5 µs
  end_time=5000; // 5 ms  => 1000 samples per channel
  array_size=0;
  cur_array_size=0;
}

void NIsequenceGenerator::set_linear(std::string channel, double time_start, double time_stop,double endvalue){
     set_linear(channel, time_start, time_stop, get_analog(channel, time_start), endvalue);
};

void NIsequenceGenerator::sort_array(unsigned long num){
  std::vector<sg_sortarraydata> a;
  int maxpinnum=-1; // while looking at all pins the program will try to convert
                    // each into a number. This is the maximum of this process.
  //std::cout<<"sort "<<num<<std::endl;
  // first generate a vector that contains all the channels that belong to array num
  for (std::map<std::string, sg_channel>::const_iterator i=channels.begin(); i!=channels.end(); ++i) {
    if (i->second.data==num) {
      sg_sortarraydata item;
      item.name=i->first;
      item.hardware_name=(*cmanager).get(i->second.name).pin_name;
      if (isRightInt(item.hardware_name)) maxpinnum=mmax(maxpinnum, extract_right_int(item.hardware_name.c_str()));
      item.offset=i->second.offset;
      a.push_back(item);
      //std::cout<<item.name<<":   "<<item.name<<"   "<<item.hardware_name<<"   "<<inttostr(item.offset)<<std::endl;
    }
  }
//  std::cout<<"vector created   "<<num<<std::endl;
  // now check for more information about this port
  sg_portinfo pinfo;
  //std::cout<<"find: "<<arrays[num].device+arrays[num].port;
  if (ports.find(arrays[num].device+NISEQGEN_DEVICE_PORT_DIVIDER+arrays[num].port)!=ports.end()) {
    pinfo=ports[arrays[num].device+NISEQGEN_DEVICE_PORT_DIVIDER+arrays[num].port];
  } else {
    pinfo.format=arrays[num].format;
    pinfo.ordering=sgUnknown;
  }
//  std::cout<<"set pinfo"<<std::endl;
  //if (pinfo.ordering==sgFree)   std::cout<<"  [free]"<<std::endl;
  //if (pinfo.ordering==sgUnknown)   std::cout<<"  [unknown]"<<std::endl;
  //if (pinfo.ordering==sgPinName)   std::cout<<"  [pinname]"<<std::endl;

  // determine width of port in bits (in variable width)
  int width;
  switch(pinfo.format) {
    case sgUInt8: width=8;    break;
    case sgUInt16: width=16;    break;
    case sgUInt32: width=32;    break;
    case sgDouble:
    case sgBinary16:
    default:
        width=-1;    break;
  }
//  std::cout<<"'"<<arrays[num].device+arrays[num].port<<"'  width="<<width<<std::endl;


  // sort items freely into the array
  if ((pinfo.ordering==sgUnknown)||(pinfo.ordering==sgFree)) {
      //std::cout<<std::endl;
      if (a.size()>1) { // sort makes sense only, if there are at least 2 items in a,
                        // but writeback has to be done even for one item in a!
        // sort the vector using bubble sort (stop sorting when there are no more
        // swaps -> O(N) on sorted array, instead of O(N^2))
        bool swapped=true;
        do {
            swapped = false;
            for (size_t i=0; i<=a.size()-2; i++) {
              //std::cout<<a[i].name<<"        "<<a[i].hardware_name<<"   "<<a[i+1].hardware_name;
              if (isRightInt(a[i].hardware_name) && isRightInt(a[i+1].hardware_name)) {
                if (extract_right_int(a[i].hardware_name) > extract_right_int(a[i+1].hardware_name)) {
                  // swap array items:
                  //std::cout<<"    swapping";
                  sg_sortarraydata temp=a[i];
                  a[i]=a[i+1];
                  a[i+1]=temp;
                  swapped = true;
                  //std::cout<<"    swapped";
                }
              } else {
                if (a[i].hardware_name > a[i+1].hardware_name) {
                  // swap array items:
                  //std::cout<<"    swapping";
                  sg_sortarraydata temp=a[i];
                  a[i]=a[i+1];
                  a[i+1]=temp;
                  swapped = true;
                  //std::cout<<"    swapped";
                }
              }
              //std::cout<<std::endl;
            }
        } while (swapped);
        //std::cout<<std::endl;
        //std::cout<<"sorted"<<std::endl;
      }

      if (a.size()>0) {

        // write back the sorted vector to the channels map
        for (size_t i=0; i<a.size(); i++) {
          //std::cout<<a[i].name<<":   "<<a[i].name<<"   "<<a[i].hardware_name<<"   "<<inttostr(i)<<std::endl;
          channels[a[i].name].offset=i;
        }
        // and set the adress_string property of the arrays item
        std::string astr="";
        if ((arrays[num].format==sgUInt8)||(arrays[num].format==sgUInt16)||(arrays[num].format==sgUInt32)) {
          //for (int i=a.size()-1; i>=0; i--) {
          for (size_t i=0; i<a.size(); i++) {
            if (astr!="") astr+=NISEQGEN_ADRESS_DIVIDER;
            astr+=get_hardware_adress((*cmanager).get(a[i].name));
          }
        }
        if (arrays[num].format==sgDouble||arrays[num].format==sgBinary16) {
          for (size_t i=0; i<a.size(); i++) {
            if (astr!="") astr+=NISEQGEN_ADRESS_DIVIDER;
            astr+=get_hardware_adress((*cmanager).get(a[i].name));
          }
        }
        arrays[num].adress_string=astr;
      }

  }

  // pinname = bit number ordering
  if (pinfo.ordering==sgPinName) {
    if (arrays[num].format==sgDouble||arrays[num].format==sgBinary16) SEQUENCER_ERRORN(SEQUENCER_ERROR_WRONGNUMBERINGANALOG_NUM, "NIsequenceGenerator.sort_array(&cm, "+inttostr(num)+")");
    if (width==-1) SEQUENCER_ERRORN(SEQUENCER_ERROR_NOWIDTH_NUM, "NIsequenceGenerator.sort_array(&cm, "+inttostr(num)+")");

    for (size_t i=0; i<a.size(); i++) {
      if (!isRightInt(a[i].hardware_name)) SEQUENCER_ERRORN(SEQUENCER_ERROR_PINNOTNUMBER_NUM, "NIsequenceGenerator.sort_array(&cm, "+inttostr(num)+"),   pin name ='"+a[i].hardware_name+"'");
      channels[a[i].name].offset=extract_right_int(a[i].hardware_name);
      if (channels[a[i].name].offset>width) SEQUENCER_ERRORN(SEQUENCER_ERROR_PINNOTNUMBERTOOBIG_NUM, "NIsequenceGenerator.sort_array(&cm, "+inttostr(num)+"),   port width = "+inttostr(width)+",   pin number = "+inttostr(channels[a[i].name].offset));
    }
    arrays[num].format=pinfo.format;
    arrays[num].adress_string=arrays[num].device+NISEQGEN_DEVICE_PORT_DIVIDER+arrays[num].port;

  }
};

std::string NIsequenceGenerator::get_hardware_adress(cm_channel channel){
  std::string res=channel.device_name;
  if (res.size()>0) res+=NISEQGEN_DEVICE_PORT_DIVIDER;
  res+=channel.port_name;
  if (channel.port_name.size()>0) res+=NISEQGEN_PORT_PIN_DIVIDER;
  res+=channel.pin_name;
  return res;
};

void NIsequenceGenerator::read_ports_ini(){
  jkiniparser ini;
  ports.clear();
  try {
     ini.readFile(portconfigfilename);
  } catch (jkipError e) {
     SEQUENCER_ERRORN(SEQUENCER_ERROR_INI_NUM, e.getMessage());
  }
  try {
    if (ini.getGroupCount()>0) {
      for (unsigned long i=0; i<ini.getGroupCount(); i++) {
        std::string g=ini.getGroupName(i);
        sg_portinfo info;
        switch(ini.getAsInt(g, "width", -1)) {
          case -1: info.format=use_binary16?sgBinary16:sgDouble; break;
          case 8: info.format=sgUInt8; break;
          case 16: info.format=sgUInt16; break;
          case 32: info.format=sgUInt32; break;
        };
        std::string o=tolower(ini.getAsString(g, "grouping", "unknown"));
        if (o=="free") { info.ordering=sgFree; }
        else if (o=="pin_name") { info.ordering=sgPinName; }
        else info.ordering=sgUnknown;
        ports[g]=info;
      }
    }
  } catch (jkipError e) {
     SEQUENCER_ERRORN(SEQUENCER_ERROR_INI_NUM, e.getMessage());
  }
}

bool NIsequenceGenerator::is_used(std::string channel){
  // first we check whether this pin is directly used:
  //if (((sequenceGenerator*)this)->is_used(channel)) return true;
  if (this->sequenceGenerator::is_used(channel)) return true;

  // now we check whether the device and port of the given channel can be found in
  // the ports map. If not, the pin_ordering is free. If they are found we have to
  // check whether pin-ordering is pin_name. If so, we have to return true, as the
  // channel is part of a port that is represented as one array, so all outputs of
  // the port have to be unreserved in NI-DAQmx.
  std::string dev=(*cmanager)[channel].device_name;
  std::string por=(*cmanager)[channel].port_name;
  sg_portinfo pinfo;
  if (ports.find(dev+NISEQGEN_DEVICE_PORT_DIVIDER+por)!=ports.end()) {
    pinfo=ports[dev+NISEQGEN_DEVICE_PORT_DIVIDER+por];
    if (pinfo.ordering==sgPinName) {
      return true;
    }
  };
  return false;
};

double NIsequenceGenerator::get_memory_usage() {
  return memusage_sample*(double)array_size;
}

double NIsequenceGenerator::get_endvalue(std::string chan, double defaultval) {
  std::map<std::string, sg_channel>::const_iterator i=channels.find(chan);
  if (i==channels.end()) return defaultval;
  if ((*cmanager)[i->second.name].type==cmDigitalOutput) {
    return get_digital(i->second.name, end_time)?1.0:0.0;
  } else {
    return get_analog(i->second.name, end_time);
  }
}

void NIsequenceGenerator::vartiming_read_ini(){
  std::string method="NIsequenceGenerator::vartiming_read_ini()";
  jkiniparser ini;
  try {
     ini.readFile(vartiming_inifile); // parse variable-timing.ini file
  } catch (jkipError e) {
     SEQUENCER_ERROR(SEQUENCER_ERROR_INI_NUM, e.getMessage(), method.c_str());
  }
  long long step=1;
  vartiming_steps.clear();
  int i=0;
  while (step>0) {
      step=ini.getAsInt("timing_steps", "s"+inttostr(i), -1);
      if (step>0) vartiming_steps.push_back((unsigned long)step);
      i++;
      //std::cout<<"     i="<<i<<"    step="<<step<<std::endl;
  }
  vartiming_sel0=ini.getAsString("channels", "sel0", "");
  vartiming_sel1=ini.getAsString("channels", "sel1", "");
  vartiming_sel2=ini.getAsString("channels", "sel2", "");
  vartiming_sel3=ini.getAsString("channels", "sel3", "");
  vartiming_stop=ini.getAsString("channels", "stop", "");
};

void NIsequenceGenerator::vartiming_set_digital(std::string channel, unsigned long long s, bool value) {
  unsigned int num=get_array_num(channel);
  unsigned char offset=get_offset(channel);
  sg_dataformat df=get_dataformat(channel);
  if (df==sgUInt32) {
    if (value) {set_bit(((uint32_t*)arrays[num].data)[s], offset);}
    else {clear_bit(((uint32_t*)arrays[num].data)[s], offset);}
    return;
  }
  if (df==sgUInt8) {
    if (value) {set_bit(((uint8_t*)arrays[num].data)[s], offset);}
    else {clear_bit(((uint8_t*)arrays[num].data)[s], offset);}
    return;
  }
  if (df==sgUInt16) {
    if (value) {set_bit(((uint16_t*)arrays[num].data)[s], offset);}
    else {clear_bit(((uint16_t*)arrays[num].data)[s], offset);}
    return;
  }
  SEQUENCER_ERRORN(SEQUENCER_ERROR_NOTDIGITAL_NUM, "NIsequenceGenerator.vartiming_set_digital(\""+channel+"\", "+inttostr(s)+", "+booltostr(value)+")");
}

bool NIsequenceGenerator::vartiming_get_digital(std::string channel, unsigned long long s) {
  unsigned int num=get_array_num(channel);
  unsigned char offset=get_offset(channel);
  sg_dataformat df=get_dataformat(channel);
  if (df==sgUInt32) {
    return bit_is_set(((uint32_t*)arrays[num].data)[s], offset);
  }
  if (df==sgUInt8) {
    return bit_is_set(((uint8_t*)arrays[num].data)[s], offset);
  }
  if (df==sgUInt16) {
    return bit_is_set(((uint16_t*)arrays[num].data)[s], offset);
  }
  SEQUENCER_ERRORN(SEQUENCER_ERROR_NOTDIGITAL_NUM, "NIsequenceGenerator.vartiming_get_digital(\""+channel+"\", "+inttostr(s)+")");
}

void NIsequenceGenerator::store_vartiming_info(unsigned long long s, unsigned char sel, bool stop) {
    //std::cout<<"store_timing_info:  s="<<s<<"  sel="<<inttostr(sel)<<"  stop="<<booltostr(stop)<<"\n";
    vartiming_set_digital(vartiming_stop, s, stop);
    vartiming_set_digital(vartiming_sel0, s, ((sel & 0x01) == 0x01) );
    vartiming_set_digital(vartiming_sel1, s, ((sel & 0x02) == 0x02) );
    vartiming_set_digital(vartiming_sel2, s, ((sel & 0x04) == 0x04) );
    vartiming_set_digital(vartiming_sel3, s, ((sel & 0x08) == 0x08) );
}


void NIsequenceGenerator::store_sample_for_compare(unsigned long long s) {
  //std::cout<<"        store_sample_for_comapre("<<s<<")\n";
  for (size_t i=0; i<arrays.size(); i++) {
      void* data=arrays[i].data;
      void* cdata=arrays[i].compare_data;
      switch(arrays[i].format) {
          case sgDouble: {
              unsigned long long base=s*arrays[i].channels;
              memcpy(cdata, &(((double*)data)[base]), arrays[i].channels*sizeof(double));
              //std::cout<<"          memcpy: to="<<cdata<<" from="<<(void*)&(((double*)data)[base])<<" count="<<arrays[i].channels*sizeof(double)<<std::endl;
              /*for (unsigned long long j=0; j<arrays[i].channels; j++) {
                  ((double*)cdata)[j]=((double*)data)[base+j];
              }*/
          } break;
          case sgBinary16: {
              unsigned long long base=s*arrays[i].channels;
              memcpy(cdata, &(((int16*)data)[base]), arrays[i].channels*sizeof(int16));
              //std::cout<<"          memcpy: to="<<cdata<<" from="<<(void*)&(((int16*)data)[base])<<" count="<<arrays[i].channels*sizeof(int16)<<std::endl;
              /*for (unsigned long long j=0; j<arrays[i].channels; j++) {
                  ((int16*)cdata)[j]=((int16*)data)[base+j];
              }*/
          } break;
          case sgUInt8: {
              unsigned long long base=s;
              *((uint8_t*)(cdata))=((uint8_t*)(data))[base];
              //std::cout<<"          uint8_t "<<cdata<<" = "<<(uint32_t)((uint8_t*)(data))[base]<<std::endl;
          } break;
          case sgUInt16: {
              unsigned long long base=s;
              *((uint16_t*)(cdata))=((uint16_t*)(data))[base];
              //std::cout<<"          uint16_t "<<cdata<<" = "<<(uint32_t)((uint16_t*)(data))[base]<<std::endl;
          } break;
          case sgUInt32: {
              unsigned long long base=s;
              *((uint32_t*)(cdata))=((uint32_t*)(data))[base];
              //std::cout<<"          uint32_t "<<cdata<<" = "<<(uint32_t)((uint32_t*)(data))[base]<<std::endl;
          } break;
      }
  }
}

void NIsequenceGenerator::copy_sample(unsigned long long from, unsigned long long to) {
  //std::cout<<"        copy_sample(from="<<from<<", to="<<to<<")\n";
  for (size_t i=0; i<arrays.size(); i++) {
      void* data=arrays[i].data;
      switch(arrays[i].format) {
          case sgDouble: {
              unsigned long long basef=from*arrays[i].channels;
              unsigned long long baset=to*arrays[i].channels;
              memcpy(&(((double*)data))[baset], &(((double*)data)[basef]), arrays[i].channels*sizeof(double));
              //std::cout<<"          memcpy: to="<<(void*)&(((double*)data))[baset]<<" from="<<(void*)&(((double*)data)[basef])<<" count="<<arrays[i].channels*sizeof(double)<<std::endl;
              /*for (unsigned long long j=0; j<arrays[i].channels; j++) {
                  ((double*)data)[baset+j]=((double*)data)[basef+j];
              }*/
          } break;
          case sgBinary16: {
              unsigned long long basef=from*arrays[i].channels;
              unsigned long long baset=to*arrays[i].channels;
              memcpy(&(((int16*)data)[baset]), &(((int16*)data)[basef]), arrays[i].channels*sizeof(int16));
              //std::cout<<"          memcpy: to="<<(void*)&(((int16*)data)[baset])<<" from="<<(void*)&(((int16*)data)[basef])<<" count="<<arrays[i].channels*sizeof(int16)<<std::endl;
          } break;
          case sgUInt8: {
              unsigned long long basef=from;
              unsigned long long baset=to;
              ((uint8_t*)data)[baset]=((uint8_t*)data)[basef];
              //std::cout<<"          uint8_t "<<(void*)&(((uint8_t*)data)[baset])<<" = "<<(uint32_t)((uint8_t*)(data))[basef]<<std::endl;
          } break;
          case sgUInt16: {
              unsigned long long basef=from;
              unsigned long long baset=to;
              ((uint16_t*)data)[baset]=((uint16_t*)data)[basef];
              //std::cout<<"          uint16_t "<<(void*)&(((uint16_t*)data)[baset])<<" = "<<(uint32_t)((uint16_t*)(data))[basef]<<std::endl;
          } break;
          case sgUInt32: {
              unsigned long long basef=from;
              unsigned long long baset=to;
              ((uint32_t*)data)[baset]=((uint32_t*)data)[basef];
              //std::cout<<"          uint32_t "<<(void*)&(((uint32_t*)data)[baset])<<" = "<<((uint32_t*)(data))[basef]<<std::endl;
          } break;
      }
  }
}

bool NIsequenceGenerator::compare_to_stored_sample(unsigned long long s) {
  //std::cout<<"        compare_to_stored_sample("<<s<<")\n";
  for (size_t i=0; i<arrays.size(); i++) {
      void* data=arrays[i].data;
      void* cdata=arrays[i].compare_data;
      switch(arrays[i].format) {
          case sgDouble: {
              unsigned long long base=s*arrays[i].channels;
              //std::cout<<"          memcmp: p1="<<arrays[i].compare_data<<" p2="<<(void*)&(((double*)data)[base])<<" count="<<arrays[i].channels*sizeof(double)<<std::endl;
              for (unsigned long long j=0; j<arrays[i].channels; j++) {
                  //std::cout<<((int16*)cdata)[j]<<"  =?=  "<<((int16*)data)[base+j]<<std::endl;
                  if (((double*)cdata)[j] != ((double*)data)[base+j]) return false;
              }
              //if (memcmp(cdata, &(((double*)data)[base]), arrays[i].channels*sizeof(double))!=0) return false;
              /*for (unsigned long long j=0; j<arrays[i].channels; j++) {
                  if (((double*)(arrays[i].compare_data))[j]!=((double*)(arrays[i].data))[base+j]) return false;
              }*/
          } break;
          case sgBinary16: {
              unsigned long long base=s*arrays[i].channels;
              //std::cout<<"          memcmp: p1="<<arrays[i].compare_data<<" p2="<<(void*)&(((int16*)data)[base])<<" count="<<arrays[i].channels*sizeof(int16)<<std::endl;
              for (unsigned long long j=0; j<arrays[i].channels; j++) {
                  //std::cout<<((int16*)cdata)[j]<<"  =?=  "<<((int16*)data)[base+j]<<std::endl;
                  if (((int16*)cdata)[j] != ((int16*)data)[base+j]) return false;
              }
              //if (memcmp(cdata, &(((int16*)data)[base]), arrays[i].channels*sizeof(int16))!=0) return false;
              /*for (unsigned long long j=0; j<arrays[i].channels; j++) {
                  if (((int16*)(arrays[i].compare_data))[j]!=((int16*)(arrays[i].data))[base+j]) return false;
              }*/
          } break;
          case sgUInt8: {
              unsigned long long base=s;
              //std::cout<<"          cmp::uint8_t p1="<<arrays[i].compare_data<<", p2="<<(void*)&(((uint8_t*)(arrays[i].data))[base])<<std::endl;
              //std::cout<<"          cmp::uint8_t v1="<<(uint32_t)*((uint8_t*)(arrays[i].compare_data))<<", v2="<<(uint32_t)(((uint8_t*)(arrays[i].data))[base])<<std::endl;
              if (*((uint8_t*)(cdata))!=((uint8_t*)(arrays[i].data))[base]) return false;
          } break;
          case sgUInt16: {
              unsigned long long base=s;
              //std::cout<<"          cmp::uint16_t p1="<<arrays[i].compare_data<<", p2="<<(void*)&(((uint16_t*)(arrays[i].data))[base])<<std::endl;
              //std::cout<<"          cmp::uint16_t v1="<<(uint32_t)*((uint16_t*)(arrays[i].compare_data))<<", v2="<<(uint32_t)(((uint16_t*)(arrays[i].data))[base])<<std::endl;
              if (*((uint16_t*)(cdata))!=((uint16_t*)(arrays[i].data))[base]) return false;
          } break;
          case sgUInt32: {
              unsigned long long base=s;
              //std::cout<<"          cmp::uint32_t p1="<<arrays[i].compare_data<<", p2="<<(void*)&(((uint32_t*)(arrays[i].data))[base])<<std::endl;
              //std::cout<<"          cmp::uint32_t v1="<<*((uint32_t*)(arrays[i].compare_data))<<", v2="<<((uint32_t*)(arrays[i].data))[base]<<std::endl;
              if (*((uint32_t*)(cdata))!=((uint32_t*)(arrays[i].data))[base]) return false;
          } break;
      }
  }
  return true;
}

void NIsequenceGenerator::save_to_csv(std::string datafilename, std::string plotfilename) {
    FILE* f=fopen(datafilename.c_str(), "w");
    //std::cout<<"output data header  "<<datafilename<<"  "<<f<<std::endl;
    std::map<std::string, sg_channel>::iterator i;
    fprintf(f, "# time [ms]");
    for (i=channels.begin(); i!=channels.end(); ++i) {
        fprintf(f, ", %s", i->second.name.c_str());
        if (i->second.name==vartiming_sel0) fprintf(f, " (vt_sel0)");
        else if (i->second.name==vartiming_sel1) fprintf(f, " (vt_sel1)");
        else if (i->second.name==vartiming_sel2) fprintf(f, " (vt_sel2)");
        else if (i->second.name==vartiming_sel3) fprintf(f, " (vt_sel3)");
        else if (i->second.name==vartiming_stop) fprintf(f, " (vt_stop)");
    }
    fprintf(f, "\n");
    //std::cout<<"output data"<<std::endl;
    double t=0;
    unsigned long long indx=0;
    while (t<end_time) {
        fprintf(f, "%10.3lf", t/1000);
        //std::cout<<t/1000<<std::endl;
        for (i=channels.begin(); i!=channels.end(); ++i) {
            sg_arraydata a=arrays[i->second.data];
            switch(a.format) {
                case sgDouble: {
                  double data=((double*)a.data)[indx*a.channels+i->second.offset];
                  fprintf(f, ", %10.7lf", data);
                  break; }
                case sgBinary16: {
                  double data=10.0*((int16*)a.data)[indx*a.channels+i->second.offset]/32768.0;
                  fprintf(f, ", %10.7lf", data);
                  break; }
                case sgUInt8:
                  if (bit_is_set(((uint8_t*)a.data)[indx], i->second.offset)) fprintf(f, ", 1"); else fprintf(f, ", 0");
                  break;
                case sgUInt16:
                  if (bit_is_set(((uint16_t*)a.data)[indx], i->second.offset)) fprintf(f, ", 1"); else fprintf(f, ", 0");
                  break;
                case sgUInt32:
                  if (bit_is_set(((uint32_t*)a.data)[indx], i->second.offset)) fprintf(f, ", 1"); else fprintf(f, ", 0");
                  break;
            }
        }
        fprintf(f, "\n");
        if (use_variable_timing) {
            unsigned char sel=vartiming_get_digital(vartiming_sel0, indx)+2*vartiming_get_digital(vartiming_sel1, indx)+4*vartiming_get_digital(vartiming_sel2, indx)+8*vartiming_get_digital(vartiming_sel3, indx);
            t+=vartiming_steps[sel];
        } else {
            t+=sample_timestep;
        }
        indx++;
    }
    fclose(f);
    //std::cout<<"output plot file"<<std::endl;
    if (plotfilename.size()>0) {
        f=fopen(plotfilename.c_str(), "w");
        fprintf(f, "reset\n");
        for (int plt=0; plt<2; plt++) {
            if (plt==0) {
                fprintf(f, "set terminal postscript color solid landscape \"Arial, 6\"\n");
                fprintf(f, "set output \"%s.ps\"\n", plotfilename.c_str());
            } else {
                fprintf(f, "set terminal win\n");
                fprintf(f, "set output \"a\"\n");
            }
            bool printed=false;
            fprintf(f, "set multiplot layout 2,1\n");
            fprintf(f, "plot [0:%10.3lf][-10:10] \\\n", end_time*1.02/1000);
            int cn=2;
            for (i=channels.begin(); i!=channels.end(); ++i) {
                sg_arraydata a=arrays[i->second.data];
                switch(a.format) {
                    case sgDouble:
                    case sgBinary16:
                      if (printed) fprintf(f, ", \\\n");
                      fprintf(f, "  \"%s\" using ($1):($%d) title \"%s\" with linespoints", datafilename.c_str(), cn, i->second.name.c_str());
                      printed=true;
                      break;
                    default:
                      break;
                }
                cn++;
            }
            fprintf(f, "\n\n\n");

            fprintf(f, "plot [0:%10.3lf][-0.5:2] \\\n", end_time*1.02/1000);
            double increment=0;
            cn=2;
            printed=false;
            for (i=channels.begin(); i!=channels.end(); ++i) {
                sg_arraydata a=arrays[i->second.data];
                switch(a.format) {
                    case sgUInt8:
                    case sgUInt16:
                    case sgUInt32: {
                        if (printed) fprintf(f, ", \\\n");
                        std::string cname=i->second.name;
                        if (i->second.name==vartiming_sel0) cname+= " (vt_sel0)";
                        else if (i->second.name==vartiming_sel1) cname+= " (vt_sel1)";
                        else if (i->second.name==vartiming_sel2) cname+= " (vt_sel2)";
                        else if (i->second.name==vartiming_sel3) cname+= " (vt_sel3)";
                        else if (i->second.name==vartiming_stop) cname+= " (vt_stop)";
                        fprintf(f, "  \"%s\" using ($1):(($%d)+%5.2lf) title \"%s\" with linespoints", datafilename.c_str(), cn, increment, cname.c_str());
                        increment+=0.002;
                        printed=true;
                      break; }
                    default:
                      break;
                }
                cn++;
            }
            fprintf(f, "\n\n\n");

            fprintf(f, "unset multiplot\n");
        }
        fclose(f);
    }
}

void NIsequenceGenerator::compress(){
    if (!use_variable_timing) return;
    //std::cout<<"read vartiming.ini"<<std::endl;
    vartiming_read_ini();
    // here we check whether the sample_timestep may be used with variable_timing
    bool ok=false;
    /*for (size_t i=0; i< vartiming_steps.size(); i++) {
      if (vartiming_steps[i]==sample_timestep) { ok=true; break; }
    }
    if (!ok) {
      SEQUENCER_ERRORN(EQUENCER_ERROR_INVALIDTIMESTEP_NUM, "NIsequenceGenerator::compress()");
    }*/


    unsigned long long read=0;
    unsigned long long write=0;
    unsigned long long block_start=0;
    unsigned long long current_timing_step=0;
    unsigned long long current_length=1;
    if (read<cur_array_size) store_sample_for_compare(read);
    //std::cout<<"starting compress:"<<std::endl;
    while (read<cur_array_size) {
        //printf("  read=%10ld,  write=%10ld,  block_start=%10ld,  current_length=%10ld, current_timing_step=%10ld  cur_array_size=%10ld\n", (long)read, (long)write, (long)block_start, (long)current_length, (long)current_timing_step, (long)cur_array_size);
        read++;
        if (compare_to_stored_sample(read)) {
            //std::cout<<"    compare true"<<std::endl;
            current_length++;
            if (current_length*sample_timestep>vartiming_steps[current_timing_step]) {
                // we crossed the next possible timestep, so we store this in current_timing_step
                // an maybe have to write the sample
                current_timing_step++;
                if (current_timing_step>=vartiming_steps.size()) {
                    // we recognized a set of equal samples with the maximal length
                    if (block_start!=write) copy_sample(block_start, write);
                    store_vartiming_info(write, current_timing_step-1, false);
                    write++;
                    block_start=read;
                    current_length=1;
                    if (read<cur_array_size) store_sample_for_compare(read);
                }
            }
            //std::cout<<"    compare true ended"<<std::endl;
        } else {
            //std::cout<<"    compare false"<<std::endl;
            // store, here we have to use all the possible timing_step sizes to fill the memory from
            // block_start until read-1 by use of an algorithm that you would use to return coins!
            for (int i=vartiming_steps.size()-1; i>=0; i--) {
                unsigned long step=vartiming_steps[i];
                //std::cout<<"      i="<<i<<"  step="<<step<<"  current_length*sample_timestep="<<current_length*sample_timestep<<std::endl;
                while ((double)current_length*sample_timestep>=(double)step) {
                    //std::cout<<"        write="<<write<<"  step="<<step<<"  current_length*sample_timestep="<<(double)current_length*sample_timestep<<std::endl;
                    if (block_start!=write) copy_sample(block_start, write);
                    //std::cout<<"        copied"<<std::endl;
                    store_vartiming_info(write, i, false);
                    //std::cout<<"        stored info"<<std::endl;
                    write++;
                    current_length-=step/(unsigned long)sample_timestep;
                }
                //std::cout<<"        end: write="<<write<<"  step="<<step<<"  current_length*sample_timestep="<<(double)current_length*sample_timestep<<std::endl;
            }
            block_start=read;
            current_length=1;
            if (read<cur_array_size) store_sample_for_compare(read);
            //std::cout<<"    compare false ended"<<std::endl;
        }
    }
    vartiming_set_digital(vartiming_stop, mmax(0,write-1), true);
    array_size=mmax(0,write); // write always points to the next writing position so if we have written 0 .. N-1
                              // write will equal N !
    if ((array_size>0) &&  (array_size%2==1)) {
        // the array size is uneven, so we add one more sample to make it even and
        // therefore #channel * #samples is even (required by NI-DAQmx)

        // first we set the previous sample to non-stop, then we copy it and set the new last sample to stop
        vartiming_set_digital(vartiming_stop, write-1, false);

        copy_sample(write-1, write);
        vartiming_set_digital(vartiming_sel0, write, false);
        vartiming_set_digital(vartiming_sel1, write, false);
        vartiming_set_digital(vartiming_sel2, write, false);
        vartiming_set_digital(vartiming_sel3, write, false);
        vartiming_set_digital(vartiming_stop, write, true);
        array_size++;
    }
    //std::cout<<"... ended compress"<<std::endl;
}

}
